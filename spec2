
if (typeof label === 'string') {
  let matchedAtps = [];

  if (cumulative?.atps?.length === 1) {
    // If only one ATP exists in cumulative, use it directly
    matchedAtps = cumulative.atps;
  } else {
    // Otherwise, filter cumulative.atps based on the label
    const matchedAtp = cumulative?.atps?.find(atp => atp?.name === label);
    if (matchedAtp) {
      matchedAtps = [matchedAtp];
    } else {
      console.error("No matching ATP found in cumulative.atps for the given label.");
      return;
    }
  }

  // Construct atpData with the matched ATP(s)
  atpData = {
    trades: trades.map(trade => ({ opicsId: trade.opicsId })), // Map trades with opicsId
    totalNoOfAtps: matchedAtps.length, // Set the count of matched ATPs
    atps: matchedAtps.map(atp => ({
      atpId: atp?.details?.atpId || null, // ATP ID
      referenceDocId: atp?.referenceDocId || null, // Reference Doc ID
      name: atp?.name || 'ATP', // ATP Name
      details: { 
        ...atp?.details // Include all details
      },
      purpose: { ...atp?.purpose }, // Include purpose
      fxDisposition: { ...atp?.fxDisposition }, // Include FX disposition
      intendedBeneficiary: { ...atp?.intendedBeneficiary }, // Include intended beneficiary
      supportingDocs: atp?.supportingDocs || null // Include supporting docs if available
    }))
  };
}
