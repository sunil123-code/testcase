

if (typeof label === 'string') {
  let matchedAtps = [];

  if (cumulative?.atps?.length === 1) {
    // If only one ATP exists in cumulative, use it directly
    matchedAtps = cumulative.atps;
  } else if (cumulative?.atps?.length > 1) {
    // Otherwise, filter cumulative.atps based on the label
    const matchedAtp = cumulative?.atps?.find(atp => atp?.name === label);
    if (matchedAtp) {
      matchedAtps = [matchedAtp];
    } else {
      console.error("No matching ATP found in cumulative.atps for the given label.");
      return;
    }
  } else {
    console.error("No ATPs available in cumulative.atps.");
    return;
  }

  if (matchedAtps.length > 0) {
    atpData = {
      trades: trades.map(trade => ({ opicsId: trade.opicsId })), // Map trades with opicsId
      totalNoOfAtps: matchedAtps.length, // Set the count of matched ATPs
      atps: matchedAtps.map(atp => ({
        atpId: atp?.details?.atpId || null, // ATP ID
        referenceDocId: atp?.referenceDocId || null, // Reference Doc ID
        name: atp?.name || 'ATP', // ATP Name
        details: { 
          ...atp?.details // Include all details
        },
        purpose: { ...atp?.purpose }, // Include purpose
        fxDisposition: { ...atp?.fxDisposition }, // Include FX disposition
        intendedBeneficiary: { ...atp?.intendedBeneficiary }, // Include intended beneficiary
        supportingDocs: atp?.supportingDocs || null // Include supporting docs if available
      }))
    };
  } else {
    console.error("Matched ATPs array is empty.");
    return;
  }

  // Convert empty strings to null in the payload
  const processedPayload = preparePayload(atpData);

  // Generate the download URL
  const url = getURL(configuration, API_NAME.DOWNLOADATP, endpoints);

  // Dispatch the processed payload with the constructed filename
  dispatch(onDownloadeAtp(configuration, filename, processedPayload, url));
}
