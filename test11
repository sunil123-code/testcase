import { AccordionRow, AccordionCol, AccordionTitle, MultiAtpLabelStyle } from '../../style/common.styles';

const MultiAccordion = ({
  isSingleOpen,
  icons,
  handleSelectedSections,
  cummulative,
  preview,
  getSingleATPSections,
  handleDownloadAtpCallBack
}) => {
  const selectedATPS = preview.previewRoutedFrom === 'ATP-Page' ? cummulative?.atps : preview?.atpsCollective;

  const callEachAtp = (atp) => getSingleATPSections(atp);

  const handleDownloadATPCallback = (e, atpName) => {
    e.stopPropagation();
    // Find the ATP data by matching the ATP name from the cummulative or preview data
    const atpData = cummulative?.atps?.find((atp) => atp.name === atpName) || preview?.atpsCollective?.find((atp) => atp.name === atpName);

    if (atpData) {
      handleDownloadAtpCallBack(atpData);  // Pass the matched ATP data to the callback function
    } else {
      console.error("ATP not found for the selected name.");
    }
  };

  const multiAtpLabel = (atp) => {
    return (
      <AccordionRow style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <AccordionCol style={{ flex: '1', textAlign: 'left' }}>
          <span>{atp.name}</span> {/* Display the ATP name */}
        </AccordionCol>
        <AccordionCol style={{ flex: '0', textAlign: 'right' }}>
          <Button
            data-testid="button-submit"
            variant="small"
            buttonType="link"
            onClick={(e) => handleDownloadATPCallback(e, atp.name)} // Pass the ATP name to filter and download
            leftIconName="ic_download"
          >
            Download {atp.name || 'ATP'} {/* Dynamically set the button text */}
          </Button>
        </AccordionCol>
      </AccordionRow>
    );
  };

  return (
    <MultiAtpLabelStyle>
      <Accordion
        theme="blue"
        variant="contained"
        iconPosition="left"
        isSingleOpen={isSingleOpen}
        icons={icons}
        selectedSections={handleSelectedSections}
        defaultCheckedSections={[0]}
      >
        {selectedATPS && selectedATPS.length > 0 ? (
          selectedATPS.map((atp) => (
            <AccordionTitle key={atp.name || atp.atpId} label={multiAtpLabel(atp)}>
              {callEachAtp(atp)}
            </AccordionTitle>
          ))
        ) : (
          <div>No ATPs available to display</div>  {/* Show a message if no ATPs */}
        )}
      </Accordion>
    </MultiAtpLabelStyle>
  );
};
===============================

export const handleDownloadATP = (configuration, trades, cumulative, preview, label, dispatch) => {
  if (!trades || trades.length === 0) {
    // eslint-disable-next-line no-console
    console.error("No trades available to process ATP download.");
    return;
  }

  // Use the new generateFilename method
  const filename = generateFilename(trades, cumulative, preview);

  let atpData = {};

  // If preview data exists, use that instead
  if (cumulative?.atps?.length > 0) {
    atpData = {
      trades: trades.map(trade => ({ opicsId: trade.opicsId })),
      totalNoOfAtps: cumulative.atps.length,
      atps: cumulative.atps.map(atp => ({
        atpId: atp?.details?.atpId || null,
        referenceDocId: atp?.referenceDocId || null,
        name: atp?.name || 'ATP',
        details: { ...atp.details },
        purpose: { ...atp.purpose },
        fxDisposition: { ...atp.fxDisposition },
        intendedBeneficiary: { ...atp.intendedBeneficiary },
      })),
    };
  } else if (preview?.atpsCollective?.length > 0) {
    // Use preview data as fallback
    const atp = typeof label === 'object'
      ? preview?.atpsCollective?.[0]
      : preview?.atpsCollective.find(item => item.name === label);

    atpData = {
      trades: trades.map(trade => ({ opicsId: trade.opicsId })),
      totalNoOfAtps: preview?.atpsCollective?.length || 0,
      atps: [{
        atpId: atp?.atpId,
        referenceDocId: atp?.referenceDocId || null,
        name: atp?.name || 'ATP 1',
        details: { ...atp?.details },
        purpose: { ...atp?.purpose },
        fxDisposition: { ...atp?.fxDisposition },
        intendedBeneficiary: atp?.intendedBeneficiary,
      }],
    };
  } else {
    console.error("No ATP data available for download.");
    return;
  }

  atpData.atps.forEach(atp => {
    delete atp.details?.sumOfBuyAmounts;
    delete atp.supportingDocs;
  });

  // Convert empty strings to null in the payload
  const processedPayload = preparePayload(atpData);

  // Generate the download URL
  const url = getURL(configuration, API_NAME.DOWNLOADATP, endpoints);

  // Dispatch the processed payload with the constructed filename
  dispatch(onDownloadeAtp(configuration, filename, processedPayload, url));
};
